<?php

namespace Surikata\Installer;

class HelperFunctions {

  // echo
  public static function echo($msg) {
    if (php_sapi_name() !== 'cli') {
      echo $msg;
    }
  }

  // loadCsvIntoArray
  public static function loadCsvIntoArray($file, $separator = ',', $enclosure = '#') {
    if (!is_file($file)) return [];

    $lines = [];

    $file = fopen($file, 'r');
    while (($line = fgetcsv($file, 0, $separator, $enclosure)) !== FALSE) {
      $lines[] = $line;
    }
    fclose($file);

    return $lines;
  }

  public static function parseDomainsToInstall($installationConfig) {
    $domainsToInstall = [];
    
    for ($i = 1; $i <= 3; $i++) {
      if (!empty($installationConfig["domain_{$i}_description"])) {
        $domainsToInstall[$i] = [
          "name" => \ADIOS\Core\HelperFunctions::str2url($installationConfig["domain_{$i}_description"]),
          "description" => $installationConfig["domain_{$i}_description"],
          "slug" => $installationConfig["domain_{$i}_slug"],
          "themeName" => $installationConfig["domain_{$i}_theme_name"],
          "languageIndex" => $installationConfig["domain_{$i}_language_index"],
        ];
      }
    }

    return $domainsToInstall;
  }

  public static function renderConfigEnvDomains($domainsToInstall = []) {
    $configEnvDomainsPHP = "<?php /* This file is auto-generated by Surikata.io installer */\r\n";
    $configEnvDomainsPHP .= "\r\n";
    $configEnvDomainsPHP .= "\$configEnv['domainLanguages'] = [1 => 'English', 2 => 'Slovensky', 3 => 'ÄŒesky'];\r\n";
    $configEnvDomainsPHP .= "\r\n";

    if (count($domainsToInstall) > 0) {
      $configEnvDomainsPHP .= '$configEnv["domains"] = ['."\r\n";
      foreach ($domainsToInstall as $domain) {
        $configEnvDomainsPHP .= "  [\r\n";
        $configEnvDomainsPHP .= "    'name' => '{$domain['name']}',\r\n";
        $configEnvDomainsPHP .= "    'description' => '{$domain['description']}',\r\n";
        $configEnvDomainsPHP .= "    'slug' => '{$domain['slug']}',\r\n";
        $configEnvDomainsPHP .= "    'rootUrl' => \$_SERVER['HTTP_HOST'].REWRITE_BASE.'{$domain['slug']}',\r\n";
        $configEnvDomainsPHP .= "    'languageIndex' => {$domain['languageIndex']},\r\n";
        $configEnvDomainsPHP .= "  ],\r\n";
      }
      $configEnvDomainsPHP .= "];\r\n";
      $configEnvDomainsPHP .= "\r\n";

      $configEnvDomainsPHP .= trim('
  $re = "/^".str_replace("/", "\\/", REWRITE_BASE)."/";
  $tmp = preg_replace($re, "", $_SERVER["REQUEST_URI"]);
  $tmppos = strpos($tmp, "/");
  $slug = ($tmppos === FALSE ? $tmp : substr($tmp, 0, $tmppos));

  $domainToRender = reset($configEnv["domains"]);
  foreach ($configEnv["domains"] as $domain) {
    if ($domain["slug"] == $slug) {
      $domainToRender = $domain;
    }
  }

  define("WEBSITE_DOMAIN_TO_RENDER", $domainToRender["name"]);
  define("WEBSITE_REWRITE_BASE", REWRITE_BASE.$domainToRender["slug"]."/");
      ');
    }

    return $configEnvDomainsPHP;
  }

  // recursiveCopy
  public static function recursiveCopy($source, $dest) {
    mkdir($dest, 0755);
    foreach (
    $iterator = new \RecursiveIteratorIterator(
      new \RecursiveDirectoryIterator($source, \RecursiveDirectoryIterator::SKIP_DOTS),
      \RecursiveIteratorIterator::SELF_FIRST) as $item
    ) {
      if ($item->isDir()) {
        mkdir($dest . DIRECTORY_SEPARATOR . $iterator->getSubPathname());
      } else {
        copy($item, $dest . DIRECTORY_SEPARATOR . $iterator->getSubPathname());
      }
    }
  }

  // recursiveRmDir
  public static function recursiveRmDir($dir, $excludeFiles = []) {
    if (!empty($dir) && is_dir($dir)) {
      $objects = scandir($dir);
      foreach ($objects as $object) {
        if ($object != "." && $object != "..") {
          if (is_dir($dir."/".$object) && !is_link($dir."/".$object)) {
            self::recursiveRmDir($dir."/".$object, $excludeFiles);
          } else {
           if (in_array($object, $excludeFiles)) {
             //
           } else {
             unlink($dir."/".$object);
           }
          }
        } 
      }
      rmdir($dir);
    }
  }

  // addFolderToZip
  public static function addFolderToZip($zip, $source, $destinationPath = "") {

    if (!file_exists($source)) {
      return false;
    }

    $source = str_replace('\\', '/', realpath($source));

    if (is_dir($source) === true) {
      $files = new \RecursiveIteratorIterator(
        new \RecursiveDirectoryIterator($source),
        \RecursiveIteratorIterator::SELF_FIRST
      );

      foreach ($files as $file) {
        $file = str_replace('\\', '/', $file);

        if (in_array(substr($file, strrpos($file, '/') + 1), ['.', '..'])) {
          continue;
        }

        $file = realpath($file);
        $file = str_replace('\\', '/', $file);

        if (is_dir($file) === true) {
          $zip->addEmptyDir($destinationPath."/".str_replace($source.'/', '', $file.'/'));
        } else if (is_file($file) === true) {
          $zip->addFromString(
            $destinationPath."/".str_replace($source.'/', '', $file),
            file_get_contents($file)
          );
        }
      }
    } else if (is_file($source) === true) {
      $zip->addFromString(
        $destinationPath."/".basename($source),
        file_get_contents($source)
      );
    }

    return TRUE;
  }

}